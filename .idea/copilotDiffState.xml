<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/Recommendationservice.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/Recommendationservice.java" />
              <option name="originalContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import com.child1.ai_service.model.Recommendation;&#10;import com.child1.ai_service.repo.RecommendationRepo;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.List;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class Recommendationservice {&#10;    private final RecommendationRepo recommendationRepo;&#10;&#10;    public List&lt;Recommendation&gt; getAllRecommendations() {&#10;        return recommendationRepo.findAll();&#10;    }&#10;&#10;    public Recommendation saveRecommendation(Recommendation recommendation) {&#10;&#10;        return recommendationRepo.save(recommendation);&#10;    }&#10;&#10;    public void deleteRecommendation(String id) {&#10;        if (recommendationRepo.existsById(id)) {&#10;            recommendationRepo.deleteById(id);&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;);&#10;        }&#10;    }&#10;&#10;    public Recommendation getActivityRecommendationById(String id) {&#10;        return recommendationRepo.findById(id)&#10;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;));&#10;        &#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import com.child1.ai_service.model.Recommendation;&#10;import com.child1.ai_service.repo.RecommendationRepo;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.validation.annotation.Validated;&#10;&#10;import javax.validation.Valid;&#10;import java.util.List;&#10;&#10;@Service&#10;@Validated&#10;@RequiredArgsConstructor&#10;public class Recommendationservice {&#10;    private final RecommendationRepo recommendationRepo;&#10;&#10;    public List&lt;Recommendation&gt; getAllRecommendations() {&#10;        return recommendationRepo.findAll();&#10;    }&#10;&#10;    public Recommendation saveRecommendation(@Valid Recommendation recommendation) {&#10;        // Additional null check (optional, as @Valid should handle most cases)&#10;        if (recommendation == null) {&#10;            throw new IllegalArgumentException(&quot;Recommendation cannot be null&quot;);&#10;        }&#10;        return recommendationRepo.save(recommendation);&#10;    }&#10;&#10;    public void deleteRecommendation(String id) {&#10;        if (recommendationRepo.existsById(id)) {&#10;            recommendationRepo.deleteById(id);&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;);&#10;        }&#10;    }&#10;&#10;    public Recommendation getActivityRecommendationById(String id) {&#10;        return recommendationRepo.findById(id)&#10;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;));&#10;        &#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/auth_service/src/main/java/com/child1/auth_service/controller/AuthController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/auth_service/src/main/java/com/child1/auth_service/controller/AuthController.java" />
              <option name="originalContent" value="package com.child1.auth_service.controller;&#10;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/auth&quot;)&#10;public class AuthController {&#10;    &#10;    &#10;    &#10;    @PostMapping(&quot;/login&quot;)&#10;    public ResponseEntity&lt;?&gt; login(@RequestBody String request) {&#10;        System.out.println(&quot;Login request received: &quot; + request);&#10;&#10;//        String token = jwtService.generateToken(request.getUsername());&#10;//        return ResponseEntity.ok(new TokenResponse(token));&#10;        // Placeholder for login logic&#10;        return ResponseEntity.ok(Map.of(&quot;message&quot;, &quot;Login successful&quot;));&#10;    }&#10;&#10;    @GetMapping(${&quot;/validate-token/{token}&quot;})&#10;    public ResponseEntity&lt;?&gt; validateToken(@PathVariable String token) { &#10;        System.out.println(&quot;Token validation request received: &quot; + token);&#10;//        boolean isValid = jwtService.validateToken(token);&#10;//        return ResponseEntity.ok(Map.of(&quot;valid&quot;, isValid));&#10;        // Placeholder for token validation logic&#10;        boolean isValid = true; // Assume token is valid for this example&#10;        return ResponseEntity.ok(Map.of(&quot;valid&quot;, isValid));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.child1.auth_service.controller;&#10;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/auth&quot;)&#10;public class AuthController {&#10;    @PostMapping(&quot;/login&quot;)&#10;    public ResponseEntity&lt;?&gt; login(@RequestBody String request) {&#10;        System.out.println(&quot;Login request received: &quot; + request);&#10;&#10;//        String token = jwtService.generateToken(request.getUsername());&#10;//        return ResponseEntity.ok(new TokenResponse(token));&#10;        // Placeholder for login logic&#10;        return ResponseEntity.ok(Map.of(&quot;message&quot;, &quot;Login successful&quot;));&#10;    }&#10;&#10;    @GetMapping(&quot;/validate-token/{token}&quot;)&#10;    public ResponseEntity&lt;?&gt; validateToken(@PathVariable String token) { &#10;        System.out.println(&quot;Token validation request received: &quot; + token);&#10;//        boolean isValid = jwtService.validateToken(token);&#10;//        return ResponseEntity.ok(Map.of(&quot;valid&quot;, isValid));&#10;        // Placeholder for token validation logic&#10;        boolean isValid = true; // Assume token is valid for this example&#10;        return ResponseEntity.ok(Map.of(&quot;valid&quot;, isValid));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_server/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_server/.gitignore" />
              <option name="originalContent" value="HELP.md&#10;target/&#10;.mvn/wrapper/maven-wrapper.jar&#10;!**/src/main/**/target/&#10;!**/src/test/**/target/&#10;&#10;### STS ###&#10;.apt_generated&#10;.classpath&#10;.factorypath&#10;.project&#10;.settings&#10;.springBeans&#10;.sts4-cache&#10;&#10;### IntelliJ IDEA ###&#10;.idea&#10;*.iws&#10;*.iml&#10;*.ipr&#10;&#10;### NetBeans ###&#10;/nbproject/private/&#10;/nbbuild/&#10;/dist/&#10;/nbdist/&#10;/.nb-gradle/&#10;build/&#10;!**/src/main/**/build/&#10;!**/src/test/**/build/&#10;&#10;### VS Code ###&#10;.vscode/&#10;resources/&#10;" />
              <option name="updatedContent" value="HELP.md&#10;target/&#10;.mvn/wrapper/maven-wrapper.jar&#10;!**/src/main/**/target/&#10;!**/src/test/**/target/&#10;&#10;### STS ###&#10;.apt_generated&#10;.classpath&#10;.factorypath&#10;.project&#10;.settings&#10;.springBeans&#10;.sts4-cache&#10;&#10;### IntelliJ IDEA ###&#10;.idea&#10;*.iws&#10;*.iml&#10;*.ipr&#10;&#10;### NetBeans ###&#10;/nbproject/private/&#10;/nbbuild/&#10;/dist/&#10;/nbdist/&#10;/.nb-gradle/&#10;build/&#10;!**/src/main/**/build/&#10;!**/src/test/**/build/&#10;&#10;### VS Code ###&#10;.vscode/&#10;resources/&#10;resources/config/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gateway/src/main/java/com/child1/gateway/AuthFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gateway/src/main/java/com/child1/gateway/AuthFilter.java" />
              <option name="originalContent" value="package com.child1.gateway;&#10;&#10;import org.springframework.cloud.client.loadbalancer.LoadBalanced;&#10;import org.springframework.cloud.gateway.filter.GlobalFilter;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.core.Ordered;&#10;import org.springframework.http.HttpHeaders;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;import org.springframework.web.server.ServerWebExchange;&#10;import reactor.core.publisher.Mono;&#10;import org.springframework.cloud.gateway.filter.GatewayFilterChain;&#10;&#10;import java.util.Map;&#10;&#10;@Component&#10;public class AuthFilter implements GlobalFilter, Ordered {&#10;&#10;    private final WebClient.Builder webClientBuilder;&#10;&#10;    public AuthFilter(WebClient.Builder webClientBuilder) {&#10;        this.webClientBuilder = webClientBuilder;&#10;    }&#10;&#10;    @Override&#10;    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {&#10;        String path = exchange.getRequest().getURI().getPath();&#10;        System.out.println(&quot;Request path: &quot; + path);&#10;        if (path.startsWith(&quot;/api/v1/auth&quot;)) {&#10;            return chain.filter(exchange);&#10;        }&#10;&#10;        String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&#10;            return exchange.getResponse().setComplete();&#10;        }&#10;&#10;        String token = authHeader.substring(7);&#10;        System.out.println(&quot;Token received: &quot; + token);&#10;//        return true;&#10;&#10;&#10;        // Connectivity check before actual validation&#10;        return webClientBuilder.build()&#10;                .get()&#10;                .uri(&quot;http://auth-service/api/v1/auth/validate?token=&quot; + token)&#10;                .exchangeToMono(response -&gt; {&#10;                    if (response.statusCode().is2xxSuccessful()) {&#10;                        return response.bodyToMono(Map.class)&#10;                                .flatMap(body -&gt; {&#10;                                    Boolean isValid = (Boolean) body.get(&quot;valid&quot;);&#10;                                    if (Boolean.TRUE.equals(isValid)) {&#10;                                        return chain.filter(exchange);&#10;                                    }&#10;                                    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&#10;                                    return exchange.getResponse().setComplete();&#10;                                });&#10;                    } else {&#10;                        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&#10;                        return exchange.getResponse().setComplete();&#10;                    }&#10;                });&#10;    }&#10;&#10;&#10;    @Override&#10;    public int getOrder() {&#10;        return -1;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.child1.gateway;&#10;&#10;import org.springframework.cloud.client.loadbalancer.LoadBalanced;&#10;import org.springframework.cloud.gateway.filter.GlobalFilter;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.core.Ordered;&#10;import org.springframework.http.HttpHeaders;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;import org.springframework.web.server.ServerWebExchange;&#10;import reactor.core.publisher.Mono;&#10;import org.springframework.cloud.gateway.filter.GatewayFilterChain;&#10;&#10;import java.util.Map;&#10;&#10;@Component&#10;public class AuthFilter implements GlobalFilter, Ordered {&#10;&#10;    private final WebClient.Builder webClientBuilder;&#10;&#10;    public AuthFilter(WebClient.Builder webClientBuilder) {&#10;        this.webClientBuilder = webClientBuilder;&#10;    }&#10;&#10;    @Override&#10;    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {&#10;        String path = exchange.getRequest().getURI().getPath();&#10;        System.out.println(&quot;Request path: &quot; + path);&#10;        if (path.startsWith(&quot;/api/v1/auth&quot;)) {&#10;            return chain.filter(exchange);&#10;        }&#10;&#10;        String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&#10;            return exchange.getResponse().setComplete();&#10;        }&#10;&#10;        String token = authHeader.substring(7);&#10;        System.out.println(&quot;Token received: &quot; + token);&#10;//        return true;&#10;&#10;&#10;        // Connectivity check before actual validation&#10;        return webClientBuilder.build()&#10;                .get()&#10;                .uri(&quot;http://auth-service/api/v1/auth/validate?token=&quot; + token)&#10;                .exchangeToMono(response -&gt; {&#10;                    if (response.statusCode().is2xxSuccessful()) {&#10;                        return response.bodyToMono(Map.class)&#10;                                .flatMap(body -&gt; {&#10;                                    Boolean isValid = (Boolean) body.get(&quot;valid&quot;);&#10;                                    if (Boolean.TRUE.equals(isValid)) {&#10;                                        return chain.filter(exchange);&#10;                                    }&#10;                                    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&#10;                                    return exchange.getResponse().setComplete();&#10;                                });&#10;                    } else {&#10;                        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);&#10;                        return exchange.getResponse().setComplete();&#10;                    }&#10;                });&#10;    }&#10;&#10;&#10;    @Override&#10;    public int getOrder() {&#10;        return -1;&#10;    }&#10;}&#10;&#10;@Configuration&#10;class WebClientConfig {&#10;    @Bean&#10;    @LoadBalanced&#10;    public WebClient.Builder loadBalancedWebClientBuilder() {&#10;        return WebClient.builder();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>