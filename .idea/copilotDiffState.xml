<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/ActivityMessListner.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/ActivityMessListner.java" />
              <option name="originalContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import com.child1.ai_service.model.Activity;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.amqp.rabbit.annotation.RabbitListener;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;&#10;@Service&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class ActivityMessListner {&#10;&#10;&#10;    private final GeminiService geminiService;&#10;&#10;    @RabbitListener(queues = &quot;activity-queue&quot;)&#10;    public void receiveMessage(Activity activity) {&#10;        System.out.println(&quot;Received message: &quot; + activity);&#10;        log.info(&quot;Received message: {}&quot;, activity);&#10;        System.out.println(&quot;Processing activity: &quot; + activity);&#10;        if (activity == null  ) {&#10;            log.error(&quot;Activity or Activity ID is null&quot;);&#10;            return;&#10;        }&#10;        String prompt = String.format(&quot;Generate a recommendation for activity with ID: %s, Type: %s, Duration: %d minutes, Calories Burned: %d, Start Time: %s&quot;,&#10;                activity.getId(),&#10;                activity.getActivityType(),&#10;                activity.getDuration(),&#10;                activity.getCaloriesBurned(),&#10;                activity.getStartTime() != null ? activity.getStartTime().toString() : &quot; not specified&quot;);&#10;        log.info(&quot;Generating activity recommendation for prompt: {}&quot;, prompt);&#10;        String response = geminiService.getResponse(prompt);&#10;        log.info(&quot;Received response from Gemini API: {}&quot;, response);&#10;        // Here you can process the response further, e.g., save it to a database or&#10;        // send it to another service.&#10;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import com.child1.ai_service.model.Activity;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.amqp.rabbit.annotation.RabbitListener;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;&#10;@Service&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class ActivityMessListner {&#10;&#10;&#10;    private final GeminiService geminiService;&#10;&#10;    @RabbitListener(queues = &quot;activity-queue&quot;)&#10;    public void receiveMessage(Activity activity) {&#10;        try {&#10;            System.out.println(&quot;Received message: &quot; + activity);&#10;            log.info(&quot;Received message: {}&quot;, activity);&#10;            System.out.println(&quot;Processing activity: &quot; + activity);&#10;            if (activity == null  ) {&#10;                log.error(&quot;Activity or Activity ID is null&quot;);&#10;                return;&#10;            }&#10;            String prompt = String.format(&quot;Generate a recommendation for activity with ID: %s, Type: %s, Duration: %d minutes, Calories Burned: %d, Start Time: %s&quot;,&#10;                    activity.getId(),&#10;                    activity.getActivityType(),&#10;                    activity.getDuration(),&#10;                    activity.getCaloriesBurned(),&#10;                    activity.getStartTime() != null ? activity.getStartTime().toString() : &quot; not specified&quot;);&#10;            log.info(&quot;Generating activity recommendation for prompt: {}&quot;, prompt);&#10;            String response = geminiService.getResponse(prompt);&#10;            log.info(&quot;Received response from Gemini API: {}&quot;, response);&#10;            // Here you can process the response further, e.g., save it to a database or&#10;            // send it to another service.&#10;            log.info(&quot;Successfully processed activity message with ID: {}&quot;, activity.getId());&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error processing activity message: &quot;, e);&#10;            // Optionally: handle the error, send to a dead-letter queue, etc.&#10;        }&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/GeminiService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/GeminiService.java" />
              <option name="originalContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import lombok.AllArgsConstructor;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Service&#10;public class GeminiService {&#10;&#10;&#10;    private final WebClient webClient;&#10;&#10;&#10;    @Value(&quot;${gemini.api.key}&quot;)&#10;    private String apiKey;&#10;    @Value(&quot;${gemini.api.url}&quot;)&#10;    private String apiUrl ;&#10;    public GeminiService(WebClient.Builder webClientBuilder) {&#10;        this.webClient = webClientBuilder.build();&#10;    }&#10;&#10;    public String getResponse(String prompt) {&#10;        // Gemini API expects a specific JSON structure. Fixing the payload structure.&#10;        Map&lt;String, Object&gt; payload = Map.of(&#10;                &quot;contents&quot;, new Object[]{&#10;                        Map.of(&quot;parts&quot;, new Object[]{&#10;                                Map.of(&quot;text&quot;, prompt)&#10;                        })&#10;                }&#10;        );&#10;        System.out.println(&quot;Requesting Gemini API with prompt: &quot; + prompt);&#10;        System.out.println(&quot;Requesting Gemini API with URL: &quot; + apiUrl + apiKey);&#10;        System.out.println(&quot;Payload: &quot; + payload);&#10;        String response = webClient.post()&#10;                .uri(apiUrl + apiKey)&#10;                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .bodyValue(payload)&#10;                .retrieve()&#10;                .bodyToMono(String.class)&#10;                .block();&#10;        if (response == null || response.isEmpty()) {&#10;            return &quot;No response from Gemini API&quot;;&#10;        }&#10;        return response;&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import lombok.AllArgsConstructor;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Service&#10;public class GeminiService {&#10;&#10;&#10;    private final WebClient webClient;&#10;&#10;&#10;    @Value(&quot;${gemini.api.key}&quot;)&#10;    private String apiKey;&#10;    @Value(&quot;${gemini.api.url}&quot;)&#10;    private String apiUrl ;&#10;    public GeminiService(WebClient.Builder webClientBuilder) {&#10;        this.webClient = webClientBuilder.build();&#10;    }&#10;&#10;    public String getResponse(String prompt) {&#10;        // Gemini API expects a specific JSON structure. Fixing the payload structure.&#10;        Map&lt;String, Object&gt; payload = Map.of(&#10;                &quot;contents&quot;, new Object[]{&#10;                        Map.of(&quot;parts&quot;, new Object[]{&#10;                                Map.of(&quot;text&quot;, prompt)&#10;                        })&#10;                }&#10;        );&#10;        System.out.println(&quot;Requesting Gemini API with prompt: &quot; + prompt);&#10;        System.out.println(&quot;Requesting Gemini API with URL: &quot; + apiUrl + apiKey);&#10;        System.out.println(&quot;Payload: &quot; + payload);&#10;        String response = webClient.post()&#10;                .uri(apiUrl + &quot;?key=&quot; + apiKey)&#10;                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .bodyValue(payload)&#10;                .retrieve()&#10;                .bodyToMono(String.class)&#10;                .block();&#10;        if (response == null || response.isEmpty()) {&#10;            return &quot;No response from Gemini API&quot;;&#10;        }&#10;        return response;&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/Recommendationservice.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ai_service/src/main/java/com/child1/ai_service/service/Recommendationservice.java" />
              <option name="originalContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import com.child1.ai_service.model.Recommendation;&#10;import com.child1.ai_service.repo.RecommendationRepo;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.List;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class Recommendationservice {&#10;    private final RecommendationRepo recommendationRepo;&#10;&#10;    public List&lt;Recommendation&gt; getAllRecommendations() {&#10;        return recommendationRepo.findAll();&#10;    }&#10;&#10;    public Recommendation saveRecommendation(Recommendation recommendation) {&#10;&#10;        return recommendationRepo.save(recommendation);&#10;    }&#10;&#10;    public void deleteRecommendation(String id) {&#10;        if (recommendationRepo.existsById(id)) {&#10;            recommendationRepo.deleteById(id);&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;);&#10;        }&#10;    }&#10;&#10;    public Recommendation getActivityRecommendationById(String id) {&#10;        return recommendationRepo.findById(id)&#10;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;));&#10;        &#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.child1.ai_service.service;&#10;&#10;&#10;import com.child1.ai_service.model.Recommendation;&#10;import com.child1.ai_service.repo.RecommendationRepo;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.validation.annotation.Validated;&#10;&#10;import javax.validation.Valid;&#10;import java.util.List;&#10;&#10;@Service&#10;@Validated&#10;@RequiredArgsConstructor&#10;public class Recommendationservice {&#10;    private final RecommendationRepo recommendationRepo;&#10;&#10;    public List&lt;Recommendation&gt; getAllRecommendations() {&#10;        return recommendationRepo.findAll();&#10;    }&#10;&#10;    public Recommendation saveRecommendation(@Valid Recommendation recommendation) {&#10;        // Additional null check (optional, as @Valid should handle most cases)&#10;        if (recommendation == null) {&#10;            throw new IllegalArgumentException(&quot;Recommendation cannot be null&quot;);&#10;        }&#10;        return recommendationRepo.save(recommendation);&#10;    }&#10;&#10;    public void deleteRecommendation(String id) {&#10;        if (recommendationRepo.existsById(id)) {&#10;            recommendationRepo.deleteById(id);&#10;        } else {&#10;            throw new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;);&#10;        }&#10;    }&#10;&#10;    public Recommendation getActivityRecommendationById(String id) {&#10;        return recommendationRepo.findById(id)&#10;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Recommendation with id &quot; + id + &quot; does not exist.&quot;));&#10;        &#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>